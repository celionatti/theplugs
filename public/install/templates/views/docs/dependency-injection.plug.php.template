@extends('layouts.docs')

@section('title', 'Dependency Injection Container')

@section('content')
<h1>Dependency Injection Container</h1>

<p>Plugs features a PSR-11 compliant container with advanced features for high-performance applications.</p>

<h2 id="scoped">1. Scoped Bindings (Per-Request singletons)</h2>

<p>Scoped services are instances that are shared within a single request cycle but are fresh for every new request. This
    is perfect for State managers or Request-specific contexts.</p>

<pre><code>// In a Service Provider
$this->container->scoped(PaymentProcessor::class);</code></pre>

<h2 id="contextual">2. Contextual Binding with Attributes</h2>

<p>Inject specific implementations directly via PHP 8 attributes. This reduces boilerplate in your providers.</p>

<pre><code>use Plugs\Container\Attributes\Inject;

class OrderService
{
    public function __construct(
        #[Inject('fast_cache')] 
        protected CacheInterface $cache
    ) {}
}</code></pre>

<h2 id="inspector">3. Visual Dependency Inspector</h2>

<p>Debug complex dependency chains by generating visual graphs.</p>

<pre><code>use Plugs\Container\Inspector;

$inspector = new Inspector();
$inspector->trace(function() {
    return app(ComplexService::class);
});

// Outputs a Mermaid.js diagram
echo $inspector->toMermaid();</code></pre>

<h2 id="auto-wiring">4. Auto-Wiring</h2>

<p>The container uses reflection to automatically resolve dependencies for any class it instantiates.</p>

<pre><code>class UserController
{
    // UserRepository and ValidationService are auto-injected
    public function __construct(
        protected UserRepository $users,
        protected ValidationService $val
    ) {}
}</code></pre>
@endsection